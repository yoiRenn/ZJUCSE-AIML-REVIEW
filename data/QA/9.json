[
    {
        "q": "人工智能中“问题求解”的五个形式化组成部分是什么？",
        "a": "1. <b>初始状态</b> (Initial State)<br>2. <b>可能行动</b> (Actions)<br>3. <b>转移模型</b> (Transition Model)<br>4. <b>目标测试</b> (Goal Test)<br>5. <b>路径耗散</b>函数 (Path Cost)"
    },
    {
        "q": "在搜索算法中，OPEN表（Frontier）和CLOSED表（Explored Set）分别有什么作用？",
        "a": "<b>OPEN表</b>：存放<b>已生成但未被扩展</b>的节点（待考察）。<br><b>CLOSED表</b>：存放<b>已经扩展过</b>的节点（已考察），用于<b>避免重复搜索</b>。"
    },
    {
        "q": "广度优先搜索 (BFS) 和深度优先搜索 (DFS) 在扩展策略和数据结构上有什么区别？",
        "a": "1. <b>BFS</b>：一层层扩展（FIFO），使用<b>队列</b> (Queue)。<br>2. <b>DFS</b>：尽可能深地扩展（LIFO），使用<b>栈</b> (Stack)。"
    },
    {
        "q": "什么是一致代价搜索 (Uniform-cost Search, UCS)？它在什么情况下是最优的？",
        "a": "UCS 总是扩展<b>路径消耗 g(n)</b> 最低的节点。<br>它是广度优先搜索的引申，当每一步代价不相等时，UCS 是<b>最优</b>的（完备且最优）。"
    },
    {
        "q": "贪婪最好优先搜索 (Greedy Best-First Search) 的评价函数是什么？它的主要缺点是什么？",
        "a": "评价函数：<b>f(n) = h(n)</b>（仅考虑当前节点到目标的<b>估计距离</b>）。<br>缺点：<b>不完备</b>（可能陷入死循环）、<b>非最优</b>（只看眼前，可能走远路）。"
    },
    {
        "q": "A* 搜索算法的评价函数是什么？其中各项代表什么？",
        "a": "<b>f(n) = g(n) + h(n)</b><br>g(n)：从初始节点到节点 n 的<b>实际</b>路径耗散。<br>h(n)：从节点 n 到目标节点的<b>估计</b>最小耗散（启发式）。"
    },
    {
        "q": "在 A* 算法中，什么是“可容许的 (Admissible)”启发式函数？",
        "a": "指 h(n) <b>从不高估</b>到达目标的最低路径耗散。<br>即：$h(n) \\le h^*(n)$（其中 $h^*$ 是真实代价）。<br>如果是树搜索，h 可容许则 A* <b>最优</b>。"
    },
    {
        "q": "曼哈顿距离 (Manhattan Distance) 和欧氏距离 (Euclidean Distance) 有什么区别？",
        "a": "<b>曼哈顿距离</b>：两点在标准坐标系上的<b>绝对轴距总和</b>（$|x_1-x_2| + |y_1-y_2|$），常用于网格移动。<br><b>欧氏距离</b>：两点间的<b>直线距离</b>（$\\sqrt{(x_1-x_2)^2 + (y_1-y_2)^2}$）。"
    },
    {
        "q": "迭代深入 A* (IDA*) 算法相对于普通 A* 算法的主要优势是什么？",
        "a": "IDA* 结合了迭代加深和 A* 的思想，使用 <b>f-cost</b> 作为截断值。<br>优势：<b>空间复杂度低</b>（<b>线性空间</b> $O(bd)$），避免了 A* 需要指数级内存来存储所有节点的问题。"
    },
    {
        "q": "局部搜索算法（如爬山法）通常适用于哪类问题？",
        "a": "适用于<b>关注解状态本身</b>（最终状态），而<b>不关心到达解的路径</b>（路径代价）的优化问题（如八皇后、TSP）。"
    },
    {
        "q": "爬山法 (Hill-climbing) 的主要缺陷有哪些？",
        "a": "1. <b>局部最优</b> (Local Maxima)：困在比周围高但不是最高的地方。<br>2. <b>高原</b> (Plateaus)：平坦区域，无法确定方向。<br>3. <b>山脊</b> (Ridges)：看似无法上升但其实可以沿着山脊走。"
    },
    {
        "q": "模拟退火算法 (Simulated Annealing) 如何避免陷入局部最优？",
        "a": "通过允许以一定的<b>概率接受“坏”的移动</b>（即向低处走）。<br>接受概率由<b>温度 T</b> 控制，随着时间推移 T 逐渐降低，接受坏移动的概率也随之降低。"
    },
    {
        "q": "遗传算法 (Genetic Algorithm) 的四个基本算子（操作）是什么？",
        "a": "1. <b>选择</b> (Selection)：优胜劣汰。<br>2. <b>交叉</b>/杂交 (Crossover)：父代片段重组。<br>3. <b>变异</b> (Mutation)：随机改变基因。<br>4. <b>复制</b> (Replication)：直接遗传给下一代。"
    },
    {
        "q": "比较 h1 (错位棋子数) 和 h2 (曼哈顿距离) 在八数码问题中的优劣。",
        "a": "<b>h2 优于 h1</b>。<br>因为对于所有节点 n，有 $h_2(n) \\ge h_1(n)$，且两者都是可容许的。h2 更接近真实代价，能显著减少 A* 算法<b>扩展的节点数</b>。"
    },
    {
        "q": "本章小结：请总结无信息搜索、启发式搜索和局部搜索的核心算法。",
        "a": "1. <b>无信息搜索</b>：BFS（广度优先）、DFS（深度优先）、UCS（一致代价）、IDS（迭代加深）。<br>2. <b>启发式搜索</b>：贪婪最好优先（f=h）、A*（f=g+h，最优需h可容许）、IDA*（节省空间）。<br>3. <b>局部搜索</b>：爬山法（贪婪，易陷局部最优）、模拟退火（概率接受劣解）、遗传算法（进化论思想）。"
    }
]